# Etherium DApp Solidity

## Solidity Feature

截至目前，我們只接觸到很少的函數修飾符。要記住所有的東西很難，所以我們來個概覽：

1. 我們有決定函數何時和被誰調用的可見性修飾符: `private`意味著它只能被合約內部調用；`internal`就像`private`但是也能被繼承的合約調用；`external`只能從合約外部調用；最後`public`可以在任何地方調用，不管是內部還是外部。

1. 我們也有狀態修飾符，告訴我們函數如何和區塊鏈交互: `view`告訴我們運行這個函數不會更改和保存任何數據；`pure`告訴我們這個函數不但不會往區塊鏈寫數據，它甚至不從區塊鏈讀取數據。這兩種在被從合約外部調用的時候都不花費任何`gas`（但是它們在被內部其他函數調用的時候將會耗費`gas`）。

1. 然後我們有了自定義的`modifiers`，例如在第三課學習的: `onlyOwner`和`aboveLevel`。對於這些修飾符我們可以自定義其對函數的約束邏輯。

這些修飾符可以同時作用於一個函數定義上：

```
function test() external view onlyOwner anotherModifier { /* ... */}
```

## 用`keccak256`來製造隨機數

`Solidity`中最好的隨機數生成器是`keccak256`哈希函數.

我們可以這樣來生成一些隨機數
```
// 生成一个0到100的随机数:
uint randNonce = 0;
uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;
randNonce++;
uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;
```
這個方法首先拿到`now`的時間戳、`msg.sender`、以及一個自增數`nonce`（一個僅會被使用一次的數，這樣我們就不會對相同的輸入值調用一次以上哈希函數了）。

然後利用`keccak`把輸入的值轉變為一個哈希值,再將哈希值轉換為`uint`,然後利用`% 100`來取最後兩位,就生成了一個0到100之間隨機數了。

這個方法很容易被不誠實的節點攻擊
在以太坊上,當你在和一個合約上調用函數的時候,你會把它廣播給一個節點或者在網絡上的`transaction`節點們。網絡上的節點將收集很多事務,試著成為第一個解決計算密集型數學問題的人，作為“工作證明”，然後將“工作證明”(Proof of Work, PoW)和事務一起作為一個`block`發布在網絡上。

一旦一個節點解決了一個`PoW`, 其他節點就會停止嘗試解決這個`PoW`, 並驗證其他節點的事務列表是有效的，然後接受這個節點轉而嘗試解決下一個節點。

**這就讓我們的隨機數函數變得可利用了**

我們假設我們有一個硬幣翻轉合約——正面你贏雙倍錢，反面你輸掉所有的錢。假如它使用上面的方法來決定是正面還是反面( `random >= 50`算正面, `random < 50`算反面)。

如果我正運行一個節點，我可以只對我自己的節點發布一個事務，且不分享它。我可以運行硬幣翻轉方法來偷窺我的輸贏—如果我輸了，我就不把這個事務包含進我要解決的下一個區塊中去。我可以一直運行這個方法，直到我贏得了硬幣翻轉並解決了下一個區塊，然後獲利。

## Infura
`Infura`是一個服務，它維護了很多以太坊節點並提供了一個緩存層來實現高速讀取。你可以用他們的API來免費訪問這個服務。用`Infura`作為節點提供者，你可以不用自己運營節點就能很可靠地向以太坊發送、接收信息。

你可以通過這樣把`Infura`作為你的`Web3`節點提供者：
```
var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));
```
不過，因為我們的`DApp`將被很多人使用，這些用戶不單會從區塊鏈讀取信息，還會向區塊鏈寫入信息，我們需要用一個方法讓用戶可以用他們的私鑰給事務簽名。

注意:以太坊(以及通常意義上的`blockchains`)使用一個公鑰/私鑰對來對給事務做數字簽名。把它想成一個數字簽名的異常安全的密碼。這樣當我修改區塊鏈上的數據的時候，我可以用我的公鑰來證明我就是簽名的那個。但是因為沒人知道我的私鑰，所以沒人能偽造我的事務。

加密學非常複雜，所以除非你是個專家並且的確知道自己在做什麼，你最好不要在你應用的前端中管理你用戶的私鑰。

不過幸運的是，你並不需要，已經有可以幫你處理這件事的服務了：`Metamask` .

## Metamask
`Metamask`是`Chrome`和`Firefox`的瀏覽器擴展，它能讓用戶安全地維護他們的以太坊賬戶和私鑰，並用他們的賬戶和使用`Web3.js`的網站互動（如果你還沒用過它，你肯定會想去安裝的——這樣你的瀏覽器就能使用`Web3.js`了，然後你就可以和任何與以太坊區塊鏈通信的網站交互了）

作為開發者，如果你想讓用戶從他們的瀏覽器里通過網站和你的`DApp`交互（就像我們在`CryptoZombies`遊戲裡一樣），你肯定會想要兼容`Metamask`的。

注意 : `Metamask`默認使用`Infura`的服務器做為`web3`提供者。就像我們上面做的那樣。不過它還為用戶提供了選擇他們自己Web3提供者的選項。所以使用`Metamask`的`web3`提供者，你就給了用戶選擇權，而自己無需操心這一塊。

使用`Metamask`的`web3`提供者
`Metamask`把它的web3提供者註入到瀏覽器的全局`JavaScript`對像`web3`中。所以你的應用可以檢查`web3`是否存在。若存在就使用`web3.currentProvider`作為它的提供者。

這裡是一些`Metamask`提供的示例代碼，用來檢查用戶是否安裝了`MetaMask`，如果沒有安裝就告訴用戶需要安裝`MetaMask`來使用我們的應用。
```
window.addEventListener('load', function() {

  // 检查web3是否已经注入到(Mist/MetaMask)
  if (typeof web3 !== 'undefined') {
    // 使用 Mist/MetaMask 的提供者
    web3js = new Web3(web3.currentProvider);
  } else {
    // 处理用户没安装的情况， 比如显示一个消息
    // 告诉他们要安装 MetaMask 来使用我们的应用
  }

  // 现在你可以启动你的应用并自由访问 Web3.js:
  startApp()

})
```
你可以在你所有的應用中使用這段樣板代碼，好檢查用戶是否安裝以及告訴用戶安裝`MetaMask`。

注意:除了`MetaMask`，你的用戶也可能在使用其他他的私鑰管理應用，比如`Mist`瀏覽器。不過，它們都實現了相同的模式來注入`web3`變量。所以我這裡描述的方法對兩者是通用的。

## Gas
結構封裝（Struct packing）省 gas 的招數
在第1課中，我們提到除了基本版的`uint`外，還有其他變種`uint`：`uint8`，`uint16`，`uint32`等。

通常情況下我們不會考慮使用`uint`變種，因為無論如何定義`uint`的大小，`Solidity`為它保留256位的存儲空間。例如，使用`uint8`而不是`uint`（uint256）不會為你節省任何`gas`。

除非，把`uint`綁定到`struct`裡面。

如果一個`struct`中有多個`uint`，則盡可能使用較小的`uint`, `Solidity`會將這些`uint`打包在一起，從而佔用較少的存儲空間。例如：
```
struct NormalStruct {
  uint a;
  uint b;
  uint c;
}

struct MiniMe {
  uint32 a;
  uint32 b;
  uint c;
}
```

## view
`view`函數不花`gas`
當玩家從外部調用一個`view`函數，是不需要支付一分`gas`的。

這是因為`view`函數不會真正改變區塊鏈上的任何數據-它們只是讀取。因此用`view`標記一個函數，意味著告訴`web3.js`，運行這個函數只需要查詢你的本地以太坊節點，而不需要在區塊鏈上創建一個事務（事務需要運行在每個節點上，因此花費`gas`）。

稍後我們將介紹如何在自己的節點上設置`web3.js`。但現在，你關鍵是要記住，在所能只讀的函數上標記上表示`只讀`的`external view`聲明，就能為你的玩家減少在`DApp`中`gas`用量。

注意：如果一個`view`函數在另一個函數的內部被調用，而調用函數與`view`函數的不屬於同一個合約，也會產生調用成本。這是因為如果主調函數在以太坊創建了一個事務，它仍然需要逐個節點去驗證。所以標記為`view`的函數只有在外部調用時才是免費的。

## storage
`Solidity`使用`storage`(存儲)是相當昂貴的，`寫入`操作尤其貴。

這是因為，無論是寫入還是更改一段數據， 這都將永久性地寫入區塊鏈。`永久性`啊！需要在全球數千個節點的硬盤上存入這些數據，隨著區塊鏈的增長，拷貝份數更多，存儲量也就越大。這是需要成本的！

為了降低成本，不到萬不得已，避免將數據寫入存儲。這也會導致效率低下的編程邏輯-比如每次調用一個函數，都需要在`memory`(內存)中重建一個數組，而不是簡單地將上次計算的數組給存儲下來以便快速查找。

在大多數編程語言中，遍歷大數據集合都是昂貴的。但是在Solidity中，使用一個標記了`external view`的函數，遍歷比`storage`要便宜太多，因為`view`函數不會產生任何花銷。（`gas`可是真金白銀啊！）。

## memory
在數組後面加上`memory`關鍵字，表明這個數組是僅僅在內存中創建，不需要寫入外部存儲，並且在函數調用結束時它就解散了。與在程序結束時把數據保存進`storage`的做法相比，內存運算可以大大節省`gas`開銷--把這數組放在`view`裡用，完全不用花錢。

以下是申明一個內存數組的例子：
```
function getArray() external pure returns(uint[]) {
  // 初始化一个长度为3的内存数组
  uint[] memory values = new uint[](3);
  // 赋值
  values.push(1);
  values.push(2);
  values.push(3);
  // 返回数组
  return values;
}
```
注意：內存數組必須用長度參數（在本例中為3）創建。目前不支持`array.push()`之類的方法調整數組大小，在未來的版本可能會支持長度修改。

## mapping
映射是另一種在`Solidity`中存儲有組織數據的方法。

映射是這樣定義的：
```
//對於金融應用程式，将用户的餘额保存在一個 uint 類型的變量中：
mapping (address => uint) public accountBalance;
//或者可以用來通過 userId 存储/查找 用户名
mapping (uint => string) userIdToName;
```
映射本質上是存儲和查找數據所用的鍵-值對。在第一個例子中，鍵是一個`address`，值是一個`uint`，在第二個例子中，鍵是一個`uint`，值是一個`string`。

## msg.sender
在`Solidity`中，有一些全局變量可以被所有函數調用。其中一個就是`msg.sender`，它指的是當前調用者（或智能合約）的`address`。

## payable
`payable` 方法是讓 `Solidity` 和以太坊變得如此酷的一部分 —— 它們是一種可以接收以太的特殊函數。

先放一下。當你在調用一個普通網站服務器上的API函數的時候，你無法用你的函數傳送美元——你也不能傳送比特幣。

但是在以太坊中，因為錢(以太)、數據(事務負載)，以及合約代碼本身都存在於以太坊。你可以在同時調用函數並付錢給另外一個合約。

這就允許出現很多有趣的邏輯，比如向一個合約要求支付一定的錢來運行一個函數。

## Web.js
以太坊節點只能識別一種叫做`JSON-RPC`的語言。這種語言直接讀起來並不好懂。當你你想調用一個合約的方法的時候，需要發送的查詢語句將會是這樣的：
```
{"jsonrpc":"2.0","method":"eth_sendTransaction","params":[{"from":"0xb60e8dd61c5d32be8058bb8eb970870f07233155","to":"0xd46e8dd67c5d32be8058bb8eb970870f07244567","gas":"0x76c0","gasPrice":"0x9184e72a000","value":"0x9184e72a","data":"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"}],"id":1}
```
幸運的是Web3.js 把這些令人討厭的查詢語句都隱藏起來了， 所以你只需要與方便易懂的`JavaScript `界面進行交互即可。

你不需要構建上面的查詢語句，在你的代碼中調用一個函數看起來將是這樣：
```
CryptoZombies.methods.createRandomZombie("Vitalik Nakamoto 🤔")
  .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" });
```
